---
title: "Watersheds"
execute:
  echo: true
format:
  html:
    toc: true
    toc-location: right
    toc-expand: false
    toc-depth: 4
    toc-title: "**On this page**"
    number-sections: false
    highlight-style: pygments
    page-layout: article

editor_options: 
  markdown: 
    wrap: 60
engine: knitr
bibliography: ../references/references.bib
csl: ../references/apa.csl
citeproc: true
---

```{r setup}
#| warning: false
#| message: false
#| error: false
#| echo: false
#| comment: NA
pacman::p_load(
  "bslib",
  "cli", "cols4all", "covr", "cowplot",
  "dendextend", "digest", "DiagrammeR", 
  "dtwclust", "downlit",
  "exactextractr", "elevatr",
  "FNN", "future", "flowdem",
  "gdalUtilities", "geojsonsf", "geos", "geodata", 
  "ggplot2", "ggstats","ggspatial", "ggmap", 
  "ggplotify", "ggpubr", "ggrepel", "giscoR",
  "hdf5r", "httr", "httr2", "htmltools",
  "jsonlite",
  "leafem", "leaflet.providers", "libgeos", 
  "luz", "lwgeom", "leaflet", "leafgl",
  "mapedit", "mapview", "maptiles", 
  "methods", "mgcv", "MPI",
  "ncdf4", "nnet",
  "openxlsx",
  "parallel", "plotly", "proj4", "PROJ", "progress", "purrr",
  "randomForest", "rasterVis", "raster", 
  "rayshader", "rayvertex", 
  "RColorBrewer", "rgl", "rmapshaper", "rsconnect", 
  "RStoolbox", "rts", "rgrass",
  "s2", "sf", "scales", "spdep", "stars", 
  "stringr", "supercells",
  "terra", "terrainr", "testthat", "traudem", 
  "tidyverse", "tidyterra", "tools",
  "tmap", "tmaptools", "terrainr",
  "whitebox", "xgboost"
  )

# bleeding edge installs
#remotes::install_github("lucarraro/traudem", force=T)
#pak::pkg_install("MPI")
#devtools::install_github("lucarraro/traudem")
#remotes::install_github("opengeos/whiteboxR", build=F)
#remotes::install_github("giswqs/whiteboxR") 
#install.packages("easypackages")

knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE, 
  warning = FALSE,
  error = FALSE, 
  comment = NA, 
  tidy.opts = list(width.cutoff = 60)
  ) 

options(
  htmltools.dir.version = FALSE, 
  htmltools.preserve.raw = FALSE)

tmap::tmap_options(component.autoscale=F,
  max.raster = c(plot=9500000, view=10000000)
  )

# whitebox doesnt like working with files in memory
# so we need to assign path to working directory 
# whitebox::install_whitebox() # install whitebox and GRASS libraries
# whitebox::wbt_init() # activate whitebox library in current directory
# list.files("/usr/local/taudem/") # Check traudem.pkg installation
# traudem::taudem_sitrep() # Check traudem dependencies
# Ignore above message "Can't find  `MoveOutletsToStrm`"

# ----- TauDEM d8 Check ---- #
# all(sapply(d8, file.exists))
# Expected result: [1] TRUE
# all(file.exists(unlist(d8)))
# Expected result: [1] TRUE
# all(map_lgl(d8, file.exists))
# Expected result: [1] TRUE
# can_register_taudem()
# Expected result: [1] TRUE
# Whitebox loaded tools: `print(wbt_list_tools())`
# Whitebox shortcuts : `print(wbt_help())`
# Whitebox version : `print(wbt_version())`
# Whitebox tool guide: `print(wbt_tool_help("lidar_info"))`\
# Whitebox parameter guide: `print(wbt_tool_parameters("slope"))`
mapviewOptions(fgb = FALSE)
sf::sf_use_s2(use_s2 = FALSE)
```

```{css, echo=FALSE, class.source = 'foldable'}
div.column {
    display: inline-block;
    vertical-align: top;
    width: 50%;
}

#TOC::before {
  content: "";
  display: block;
  height:200px;
  width: 200px;
  background-image: url('https://raw.githubusercontent.com/seamusrobertmurphy/map-templates/refs/heads/main/assets/outputs/06-watershed-3D.png');
  background-size: contain;
  background-position: 50% 50%;
  padding-top: 80px !important;
  background-repeat: no-repeat;
}
```

## 2.0 Overview

This analysis performs geomorphological processing of
digital elevation models (DEMs) to extract critical
watershed characteristics needed for hydrological modeling.
We implement two complementary workflows for watershed
delineation and hydraulic network analysis, comparing two
approaches using `flowdem` [@flowdem] and `whitebox`
[@whitebox] packages with `RichDEM` [@RichDEM], `GDAL 3.11`
[@GDAL] and `r-spatial` [@terra; @sf; @stars] libraries.

## 2.1 Declare AOIs

```{r pop-aoi}
#| warning: false
#| message: false
#| error: false
#| echo: true
#| eval: true
#| comment: NA

crs_master = sf::st_crs("EPSG:3857")
country = giscoR::gisco_get_countries(
  country = "Malawi", resolution = "3") |>
  sf::st_cast() |> sf::st_transform(crs_master)
lake  = sf::st_read("../assets/inputs/lakes_site.shp") |>
  sf::st_cast() |> sf::st_transform(crs_master)

bbox = lake |>
  sf::st_buffer(dist = 60000) |> 
  sf::st_bbox() |>
  sf::st_as_sfc() |>
  sf::st_sf()

# Interactive map mode: "view"
tmap::tmap_mode("view")
tmap::tm_shape(country) + tmap::tm_borders(lwd=1, col= "green") +
  tmap::tm_shape(bbox) + tmap::tm_borders(lwd=2, col= "orange") +
  tmap::tm_shape(lake) + tmap::tm_borders(lwd=2, col= "blue") +
  tmap::tm_basemap("Esri.WorldImagery")
```

Figure 2a: Interactive map illustrating layout of area of
interest polygons (AOI)

## 2.2 Download DEM

We acquired elevation data using the `elevatr` package
[@elevatr] that accesses via Amazon Web Services Terrain
Tiles and the Open Topography Global DEM API collections of
global digital elevation models including SRTMGL3, SRTMGL1,
AW3D30, and SRTM15Plus. Depending on source, `OSM`'s Slippy
Tiling syntax[^1] is used where zoom represents number of
vertical tiles counting from top-left corner in a
Peudo-Mercator grid ([EPSG:3857](https://epsg.io/3857)). At
lower latitudes, setting parameters to `zoom=11` should
return a data resolution of 3-arc-seconds (76m at 0°Lat).
This allows us to then resample to a standardized 100m grid,
which is useful for downstream metrics during watershed
analysis. To limit dependency conflicts, a `crs_master`
variable was derived above and applied below going forward.

```{r watershed-dem}
#| warning: false
#| message: false
#| error: false
#| eval: false
#| echo: true
#| comment: NA

# z = 12: 1-Arc Second Resolution
# z = 11: 3-Arc Second Resolution
# z = 10: 5-Arc Second Resolution
dem = elevatr::get_elev_raster(bbox, z=10, clip="locations") |> terra::rast() 
names(dem) = "elevation" 

dem_100m  = stars::st_warp(
  stars::st_as_stars(dem), 
  cellsize=100, crs=sf::st_crs(crs_master)) |>
  terra::rast()

# Outputs
terra::writeRaster(dem_100m, overwrite = TRUE,
  "../assets/TIF/dem_chilwa_00_raw.tif")
```

## 2.3 Flowdem Tools

The `flowdem` package [@flowdem] provides a streamlined R
interface to `RichDEM` library, offering computationally
efficient implementations of depression breaching, filling,
and flow routing operations. While the `WhiteboxTools`
workflow below (Section 2.3) provides more comprehensive
control over individual processing steps, the `flowdem`
approach enables rapid exploratory analysis through
integrated functions that combine multiple operations. This
"quick and efficient" methodology is particularly valuable
for initial watershed characterization and iterative
parameter testing.

We present the `flowdem` workflow as a complementary
approach demonstrating that multiple algorithmic
implementations can yield consistent watershed boundaries
when applied to the same study system. Comparing outputs
from both `flowdem` and `whitebox` packages also allows for
validation of challenging data tasks such as endorheic basin
delineation.

### Hydraulic Conditioning

`RichDEM`'s depression handling implements priority-flood
algorithms [@RichDEM; @barnes2014priority] that efficiently
process large DEMs through optimized queue-based operations.
The `flowdem::breach()` function carves minimal-depth
channels through depressions, while `flowdem::fill()` with
epsilon gradient (`epsilon = TRUE`) ensures continuous
downstream flow by adding infinitesimal increments to flat
areas. This combined approach removes topological barriers
to flow routing while preserving the computational
efficiency advantages of the RichDEM implementation.

The epsilon filling parameter adds small elevation
increments (typically 10⁻⁶ to 10⁻⁴ m) to ensure strict
monotonic descent along flow paths, preventing ambiguous
flow directions in perfectly flat terrain common to
marshland environments. This is varies slightly to the
`WhiteboxTools` `flat_increment` parameter, though both
achieve similar outcomes through slightly different
numerical implementations.

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: false
#| echo: true
#| comment: NA
# Inputs
dem_100m   = terra::rast("../assets/TIF/dem_chilwa_00_raw.tif")

# Apply breaching & filling to depressions & flats
dem_breach = flowdem::breach(dem_100m) 
dem_fill   = flowdem::fill(dem_breach, epsilon=T) 

# Visualize hydraulic conditioning
dem_breach_diff <- dem_100m - dem_breach
dem_breach_diff[dem_breach_diff == 0] <- NA
dem_fill_diff <- dem_100m - dem_fill
dem_fill_diff[dem_fill_diff == 0] <- NA

tmap::tmap_mode("plot")
tmap::tm_shape(dem_breach_diff) + tmap::tm_raster(col.scale=tm_scale_continuous(
    values = hcl.colors(50, rev = TRUE),midpoint = 0), col.legend = tm_legend(title="")) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_title("Effects of Breaching", size=.8) -> tm_breach

tmap::tm_shape(dem_fill_diff) + tmap::tm_raster(col.scale = tm_scale_continuous(
    values = hcl.colors(50, rev = TRUE),midpoint = 0), col.legend = tm_legend(title="")) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_title("Effects of Filling", size=.8) -> tm_fill
tmap::tmap_arrange(tm_breach, tm_fill, nrow=1)

# Outputs
terra::writeRaster(dem_breach, overwrite = TRUE,
  "../assets/TIF/dem_chilwa_01_breached.tif")
terra::writeRaster(dem_fill, overwrite = TRUE,
  "../assets/TIF/dem_chilwa_02_filled.tif")
```

![Figure 2b: Map illustrating effects of breaching and
filling on elevation
model.](https://raw.githubusercontent.com/seamusrobertmurphy/map-templates/refs/heads/main/assets/MAP/breach-effects.png){fig-align="center"}

### Flow Accumulation

Flow routing follows the D8 algorithm [@o1984extraction]
implemented through RichDEM's optimized structures. The
`flowdem::dirs()` function calculates flow direction
pointers, which are then used as input to compute flow
accumulation. This follows familiar two-step process of
other workflows, but executes using a more memory-efficient
function often useful when importing large raster and point
cloud datasets.

The Flow accumulation values represent the number of
upstream cells contributing flow to each location, identical
in interpretation to `WhiteboxTools` outputs. At 100m
resolution, each cell represents 0.01 km² (1 hectare) of
contributing area, enabling direct conversion between cell
counts and drainage area in km².

```{r}
#|warning: false
#|message: true 
#|error: false 
#|eval: false 
#|echo: true 
#|comment: NA
# Inputs
dem_breach = terra::rast("../assets/TIF/dem_chilwa_01_breached.tif")
dem_fill = terra::rast("../assets/TIF/dem_chilwa_02_filled.tif")

# D8 flow direction + accumulation from filled DEM
dem_dir <- flowdem::dirs(dem_fill, mode = "d8") 
dem_acc <- flowdem::accum(dem_dir, mode = "d8")

# Verify flow accumulation statistics
cat("Flow accumulation summary (flowdem):\n")
cat("Minimum:", min(values(dem_acc), na.rm = TRUE),"cells\n") 
cat("Median:", median(values(dem_acc), na.rm =TRUE), "cells\n") 
cat("Maximum:", max(values(dem_acc), na.rm= TRUE), "cells\n") 
cat("Max contributing area:", round(max(values(dem_acc), na.rm=T) * 0.01, 1), "km²\n")
streams = dem_acc >= 1000 |> as.lines(streams)
streams[streams == 0] <- NA  # Remove non-stream cells

# Visualise
tmap::tmap_mode("view")
tmap::tm_shape(lake) + tmap::tm_raster(
  values="OrRd", title = "D8 Flow Acc.",
  breaks = c(1, 2, 3, 5, 10, 50, 100, 1000, 1200000),
  labels = c("1-2", "2-3", "3-5", "5-10", "10-50", "50-100", "100-1K", ">1K")) +
  tmap::tm_shape(lake) + tmap::tm_borders(col = "turquoise", lwd = 2) +
  tmap::tm_layout(legend.text.size = 0.8, legend.title.size = 1)

# Outputs
terra::writeRaster(dem_dir, overwrite=T,
  "../assets/TIF/dem_chilwa_03_flow_direction.tif")
terra::writeRaster(dem_acc, overwrite=T, 
  "../assets/TIF/dem_chilwa_04_flow_accumulation.tif")
```

Figure 2c: Interactive map illustrating flow accumulation
results

## 2.4 Watershed Delineation

The `flowdem::watershed()` function identifies all cells
that drain to a specified feature, in this case, the Lake
Chilwa boundary polygon. This approach differs from
pour-point-based methods by using the entire lake perimeter
as the drainage terminus, automatically capturing all flow
paths converging on the water body. For endorheic systems
where the terminal sink is spatially extensive (Lake Chilwa
spans \~60 km N-S), this polygon-based approach may be more
robust than single-point methods, as it captures multiple
convergent flow paths around the lake's perimeter.

The resulting watershed polygon represents the complete
catchment area draining to Lake Chilwa through surface flow
pathways identified by the D8 algorithm. Post-processing
converts the raster watershed output to vector format for
integration with other spatial datasets and area
calculations.

```{r watershed-dem-hidden}
#| warning: false
#| message: false
#| error: false
#| echo: true
#| eval: false
#| comment: NA
# Inputs
dem_dir = terra::rast("../assets/TIF/dem_chilwa_03_flow_direction.tif")
dem_acc = terra::rast("../assets/TIF/dem_chilwa_04_flow_accumulation.tif")

# Delineate extent of watershed drainage area
watershed = flowdem::watershed(dem_dir, lake) |>
  terra::as.polygons() |>
  sf::st_as_sf()

# Visual check
tmap::tmap_mode("plot")
tmap::tm_shape(watershed) + tmap::tm_borders(col = "turquoise", lwd = 2) +
  tmap::tm_shape(streams) + tmap::tm_lines(col = "royalblue", lwd = 1) +
  tmap::tm_shape(lake) + tmap::tm_polygons(fill = "royalblue") +
  tmap::tm_layout(legend.text.size = 0.8, legend.title.size = 1) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_compass(color.dark="gray60",position=c("RIGHT", "top")) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2)

# Outputs
sf::st_write(watershed, "../assets/SHP/watershed_chilwa_05_flowdem.shp", delete_dsn=T)
```

## 2.5 Whitebox Tools

Lake Chilwa represents a critical challenge for standard
watershed delineation as an endorheic, closed basin where
water accumulates through surface inflow and evaporation
without surface outflow. Traditional hydrological algorithms
[@o1984extraction] assume exorheic drainage systems with
defined pour points where water exits the catchment. For
endorheic systems, we adapted this workflow principally by
first estimating terminal sink points near to maximum flow
values within the lake basin to compute drainages of
internal sub-basins and delineating the watershed outwards.
Implementation steps were as follows:

-   Hydraulic breaching and filling,
-   D8 Flow direction and accumulation,
-   Depression network characterization,
-   Derive terminal drainage points,
-   Delineate watershed and streams.

### Hydraulic Conditioning

Digital elevation models contain spurious depressions and
flat areas arising from data acquisition artifacts,
interpolation errors, and measurement precision limitations
[@lindsay2016efficient]. Artifacts disrupt continuous flow
path connectivity essential for watershed delineation.
Hydraulic conditioning removes these features while
preserving genuine topographic depressions such as Lake
Chilwa's endorheic basin.

We applied depression breaching [@lindsay2016efficient]
fitted with minimal-cost pathways and depression gradients
(\<3m depth) while preserving the primary lake basin. This
approach removes DEM artifacts more conservatively without
artificially draining the local system.

We applied depression filling using the Wang & Liu algorithm
[@wang2006efficient] to smooth remaining flat areas through
scan-line method specifically suited to low-relief terrain.
The combined breach-then-fill strategy balances
computational efficiency with preservation of hydrologically
meaningful features

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: false
#| echo: true
#| comment: NA
# 1a. Conservative breaching of shallow depressions (<3m) 
# while preserving the primary Lake Chilwa basin
whitebox::wbt_breach_depressions(
  dem     = "dem_chilwa_00_raw.tif",
  output  = "dem_chilwa_11_breached_flat.tif",
  wd      = "../assets/TIF/",
  max_depth = 3,  # Only breach shallow artifacts
  flat_increment = 0.001
)

# 1b. Depression filling using Wang & Liu (2006) algorithm
# Optimized for flat terrain typical of marshlands
whitebox::wbt_fill_depressions_wang_and_liu(
  dem   = "dem_chilwa_11_breached_flat.tif",
  output= "dem_chilwa_12_filled_wang.tif",
  wd    = "../assets/TIF/"
)

# 1c. Quantify conditioning effects
dem_breach = terra::rast("../assets/TIF/dem_chilwa_11_breached_flat.tif")
dem_filled = terra::rast("../assets/TIF/dem_chilwa_12_filled_wang.tif")

depression_effect <- dem_filled - dem_breach
breach_effect = dem_100m - dem_breach  
fill_effect   = dem_filled - dem_breach
total_effect  = dem_filled - dem_100m  

breach_effect[breach_effect == 0] <- NA
fill_effect[fill_effect == 0] <- NA
total_effect[total_effect == 0] <- NA
total_log <- log10(total_effect + 0.01)  # +0.01 to handle small values

# Visualize hydraulic conditioning
tmap::tmap_mode("plot")
tmap::tm_shape(breach_effect) + tmap::tm_raster(col.scale = tm_scale_continuous(
    values = hcl.colors(50, rev = T),midpoint=0),col.legend=tm_legend(title="")) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_compass(color.dark="gray60",position=c("RIGHT", "top")) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_title("Effects of Breaching", size=.8) -> tm_breach

tmap::tm_shape(fill_effect) + tmap::tm_raster(col.scale = tm_scale_continuous(
    values = hcl.colors(50, rev = T),midpoint=0),col.legend=tm_legend(title="")) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_compass(color.dark="gray60",position=c("RIGHT", "top")) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_title("Effects of Filling", size=.8) -> tm_fill
tmap::tmap_arrange(tm_breach, tm_fill, nrow=1)

tmap::tmap_mode("view")
tmap::tm_shape(breach_effect) + tmap::tm_raster(
    palette = "Blues", title = "Depth (m)", style = "cont") +
  tmap::tm_shape(fill_effect) + tmap::tm_raster(
    values = "Oranges", title = "Depth (m)", style = "cont") +
  tmap::tm_shape(total_effect) + tmap::tm_raster(
    values = "YlOrRd", title = "Depth (m)", style = "cont") +
  tmap::tm_shape(lake) + tmap::tm_borders(col = "red", lwd = 1.5) +
  tmap::tm_layout(main.title = "Effects of Breaching")

# Save for later
terra::writeRaster(depression_effect, overwrite=T,
  "../assets/TIF/dem_chilwa_13_depression_effects.tif")
terra::writeRaster(breach_effect, overwrite = T, 
  "../assets/TIF/dem_chilwa_11_breach_effect.tif")
terra::writeRaster(fill_effect, overwrite = T,
  "../assets/TIF/dem_chilwa_12_fill_effect.tif")
terra::writeRaster(total_effect, overwrite = T,
  "../assets/TIF/dem_chilwa_13_total_effect.tif")
```

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: true
#| echo: false
#| comment: NA

dem_breach = terra::rast("../assets/TIF/dem_chilwa_11_breached_flat.tif")
dem_filled = terra::rast("../assets/TIF/dem_chilwa_12_filled_wang.tif")

breach_effect = terra::rast("../assets/TIF/dem_chilwa_11_breach_effect.tif")
fill_effect   = terra::rast("../assets/TIF/dem_chilwa_12_fill_effect.tif")
total_effect  = terra::rast("../assets/TIF/dem_chilwa_13_total_effect.tif")
 
tmap::tmap_mode("plot")
tmap::tm_shape(breach_effect) + tmap::tm_raster(col.scale = tm_scale_continuous(
    values = hcl.colors(50, rev = TRUE),midpoint=0),col.legend=tm_legend(title="")) +  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_title("Effects of Breaching", size=.8) -> tm_breach

tmap::tm_shape(fill_effect) + tmap::tm_raster(col.scale = tm_scale_continuous(
    values = hcl.colors(50, rev = TRUE),midpoint=0),col.legend=tm_legend(title="")) +  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_title("Effects of Filling", size=.8) -> tm_fill
tmap::tmap_arrange(tm_breach, tm_fill, nrow=1)

tmap::tmap_mode("view")
tmap::tm_shape(breach_effect) + tmap::tm_raster(
    palette = "Blues", title = "Depth (m)", style = "cont") +
  tmap::tm_shape(fill_effect) + tmap::tm_raster(
    values = "Oranges", title = "Depth (m)", style = "cont") +
  tmap::tm_shape(total_effect) + tmap::tm_raster(
    values = "YlOrRd", title = "Depth (m)", style = "cont") +
  tmap::tm_shape(lake) + tmap::tm_borders(col = "red", lwd = 1.5) +
  tmap::tm_layout(main.title = "Effects of Breaching & Filling")
```

### Flow Accumulation

Flow accumulation was computed using the D8
single-flow-direction algorithm [@o1984extraction] via the
`whitebox` function `wbt_d8_flow_accumulation()`
[@whitebox-2; @lindsay2016whitebox]. The algorithm routes
flow from each cell to its steepest downslope neighbor among
eight adjacent cells. Flow accumulation values represent the
number of upstream cells contributing flow to each location.
At 100m spatial resolution, 1 cell = 0.01 km² contributing
area.

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: false
#| echo: true
#| comment: NA
# 2a. Calculate D8 flow direction
whitebox::wbt_d8_pointer(
  dem = "dem_chilwa_12_filled_wang.tif",
  output = "dem_chilwa_13_flow_direction_D8.tif",
  wd = "../assets/TIF/"
)

# 2b. Calculate flow accumulation
# Output units: number of upstream cells contributing flow
# At 100m resolution: 1 cell = 0.01 km² contributing area
whitebox::wbt_d8_flow_accumulation(
  input = "dem_chilwa_13_flow_direction_D8.tif", 
  output= "dem_chilwa_14_flow_accumulation_D8.tif",
  wd    = "../assets/TIF/",
  pntr  = T
  )
```

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: true
#| echo: true
#| comment: NA
# Visual check
dem_acc = terra::rast("../assets/TIF/dem_chilwa_14_flow_accumulation.tif")

tmap::tmap_mode("view")
tmap::tm_shape(dem_acc) + tmap::tm_raster(
  values="OrRd", title = "D8 Flow Accumulation",
  breaks = c(1, 2, 3, 5, 10, 50, 100, 1000, 1200000),
  labels = c("1-2", "2-3", "3-5", "5-10", "10-50", "50-100", "100-1K", ">1K")) +
  tmap::tm_shape(lake) + tmap::tm_borders(col = "turquoise", lwd = 2) +
  tmap::tm_layout(legend.text.size = 0.8, legend.title.size = 1)
```

### Depression Analysis

Endorheic basins are characterized by internal drainage
networks where water accumulates in topographic depressions
without surface outflow. We quantified two complementary
metrics to characterize Lake Chilwa's depression structure:

1.  depth in sink, measuring the vertically from cell to
    spillover point,
2.  topographic wetness index (TWI), indicating locations
    prone to water accumulation based on upslope
    contributing area and local slope.

Depth in sink analysis was performed on the raw
(unconditioned) DEM to preserve actual depression depths,
while TWI calculation used the hydrologically conditioned
DEM and flow accumulation to ensure topologically consistent
flow routing. These metrics jointly identify the spatial
extent and hydrological characteristics of the endorheic
system.

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: true
#| echo: true
#| comment: NA
# 3a. Calculate depth within depressions using raw 
# or unbreached DEM to measure depth below spillover points
whitebox::wbt_depth_in_sink(
  dem = "dem_chilwa_00_raw.tif",
  output = "dem_chilwa_15_sink_depth.tif", 
  wd = "../assets/TIF/",
  zero_background = F
)

# 3b. Calculate topographic wetness index to support
# delineation of marshland in marginal zones
whitebox::wbt_wetness_index(
  sca = "dem_chilwa_14_flow_accumulation_D8.tif",
  slope = "dem_chilwa_12_filled_wang.tif",  
  output = "dem_chilwa_16_wetness_index.tif",
  wd = "../assets/TIF/"
)

sink_depth <- terra::rast("../assets/TIF/dem_chilwa_15_sink_depth.tif")
wetness_idx <- terra::rast("../assets/TIF/dem_chilwa_16_wetness_index.tif")
flow_accum <- terra::rast("../assets/TIF/dem_chilwa_14_flow_accumulation_D8.tif")

tmap::tmap_mode("view")
tmap::tm_shape(sink_depth) + tmap::tm_raster(values = "Blues", 
  alpha=0.7, title = "Sink Depth (m)", style = "quantile", n=7) +
  tmap::tm_shape(wetness_idx) + tmap::tm_raster(values="YlGnBu", 
  alpha=0.5, title="Wetness Index", style = "quantile", n=7) +
  tmap::tm_shape(lake) + tmap::tm_borders(col = "turquoise", lwd = 2) +
  tmap::tm_layout(legend.text.size = 0.8, legend.title.size = 1) +
  tmap::tm_basemap("Esri.WorldImagery")

par(mfrow = c(1, 2))
hist(sink_depth[sink_depth <= 25], breaks = 30,
     main = "Depths 0-10m", xlab = "Depth (m)", col = "steelblue")
hist(values(wetness_idx), breaks = 50, xlab = "TWI Value", 
     main = "Distribution of Wetness Index", col = "darkgreen")
```

### Terminal Pour Points

Standard watershed delineation algorithms require pour
points (outlet locations) where accumulated flow exits the
drainage system. For endorheic basins lacking surface
outflow, we identified terminal drainage points at locations
of maximum flow accumulation within the lake basin,
representing the ultimate destination of all surface
drainage [@lehner2022global; @zhang2020national]
[@li2025enhanced].

Terminal points were identified through interactive
digitization using flow accumulation as reference. We tested
both single-point and multi-point configurations to assess
sensitivity of watershed delineation to pour point placement
in flat terrain. Points were placed at the lake center where
flow accumulation exceeds 1 million cells, confirming
successful convergence of watershed-scale drainage .

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: false
#| echo: true
#| comment: NA

# Assign terminal sink points near high flow accumulation
outlets = mapedit::editMap(mapview::mapView(dem_acc)) 
outlets = outlets$all |> # convert to sf
  sf::st_transform(crs_master) |>
  dplyr::select(geometry)
outlets$id <- "chilwa_drainage_terminus_single"

# Add terminal sink points to improve watershed delineation
outlets_add = mapedit::editMap(mapview::mapView(dem_acc)) 
outlets_add = outlets_add$all |> # convert to sf
  sf::st_transform(crs_master) |>
  dplyr::select(geometry)
outlets_add$id <- "chilwa_drainage_terminus_multiple"

# Visualize & save points for reproducibility
sf::st_write(outlets, "../assets/SHP/outlets.shp", delete_layer=T, quiet=T)
sf::st_write(outlets_add, "../assets/SHP/outlets_multiple.shp", delete_layer=T)
dem_acc   = terra::rast("../assets/TIF/dem_chilwa_14_flow_accumulation.tif")
tmap::tm_shape(dem_acc) + tmap::tm_raster(values="brewer.reds") +
  tmap::tm_shape(lake) + tmap::tm_borders(col="lightblue") +
  tmap::tm_shape(outlets) + tmap::tm_symbols(shape="id",lwd=2)
```

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: true
#| echo: false
#| comment: NA

# Visualize terminal flow points
outlets = sf::st_read("../assets/SHP/outlets_multiple.shp", quiet=T)
dem_acc = terra::rast("../assets/TIF/dem_chilwa_14_flow_accumulation.tif")
tmap::tm_shape(dem_acc) + tmap::tm_raster(
  values="OrRd", title = "D8 Flow Accumulation",
  breaks = c(1, 2, 3, 5, 10, 50, 100, 1000, 1200000),
  labels = c("1-2", "2-3", "3-5", "5-10", "10-50", "50-100", "100-1K", ">1K")) +
  tmap::tm_shape(outlets) + tmap::tm_symbols(shape="id",lwd=2) +
  tmap::tm_shape(lake) + tmap::tm_borders(col = "turquoise", lwd = 2) +
  tmap::tm_layout(legend.text.size = 0.8, legend.title.size = 1)

```

## 2.6 Streams Delineation

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: false
#| echo: true
#| comment: NA

# Stream Classification 
whitebox::wbt_extract_streams(
  flow_accum= "dem_chilwa_14_flow_accumulation_D8.tif", 
  output    = "dem_chilwa_18_streams_sensitive.tif",
  wd        = "../assets/TIF/", 
  zero_background = T,
  threshold = 25, 
  )

whitebox::wbt_remove_short_streams(
  d8_pntr   = "dem_chilwa_14_flow_direction_D8.tif",  # flow direction
  streams   = "dem_chilwa_18_streams_sensitive.tif",
  output    = "dem_chilwa_19_streams_d8.tif",
  wd        = "../assets/TIF/",
  min_length= 200,
  )

whitebox::wbt_find_main_stem(
  d8_pntr = "dem_chilwa_14_flow_direction_D8.tif",
  streams = "dem_chilwa_19_streams_d8.tif",
  output = "dem_chilwa_20_streams_trunk.tif",
  wd = "../assets/TIF/"
)

whitebox::wbt_raster_streams_to_vector(
  streams = "dem_chilwa_20_streams_trunk.tif",
  d8_pntr = "dem_chilwa_14_flow_direction_D8.tif",
  output = "../assets/SHP/streams_chilwa.shp",
  wd = "../assets/TIF/"
)
```

```{r}
#| warning: false
#| message: false
#| error: false
#| eval: true
#| echo: true
#| comment: NA
# Inputs
streams_sf = sf::st_read("../assets/SHP/streams_chilwa.shp")
dem_filled = terra::rast("../assets/TIF/dem_chilwa_12_filled_wang.tif")
sf::st_crs(streams_sf) = 3857

# Visualize
tmap::tm_shape(dem_filled) + tmap::tm_raster(palette = "Greens") +
  tmap::tm_shape(lake) + tmap::tm_borders(col = "turquoise", lwd = 2) +
  tmap::tm_shape(streams_sf) + tmap::tm_lines(col = "steelblue") +
  tmap::tm_layout(legend.text.size = 0.8, legend.title.size = 1)
```

```{r}
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| comment: NA

watershed= terra::vect("../assets/inputs/hydro/hybas_lake_af_lev04_v1c.shp")
rivers   = terra::vect("../assets/inputs/hydro/HydroRIVERS_v10.shp") 

rivers_country = terra::crop(rivers, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
rivers_site = terra::crop(rivers, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

lakes_country = terra::crop(lakes, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
lakes_site = terra::crop(lakes, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

aoi_site   = sf::read_sf("../assets/inputs/chilwa_watershed_4326.shp") |>
  st_cast() |> st_transform(crs_master)
aoi_country <- giscoR::gisco_get_countries(country = "Malawi", resolution = "3") |>
  st_cast() |>
  st_transform(crs_master)

# Interactive map mode: "view"
tmap::tmap_mode("view")
tmap::tm_shape(aoi_country) +
  tmap::tm_borders(lwd = 1, col = "green") +
  tmap::tm_shape(aoi_site) +
  tmap::tm_borders(lwd = 2, col = "red")

tmap::tm_shape(dem_site) + tmap::tm_raster(palette = "Greens") +
  tmap::tm_shape(rivers_site) + tm_lines(col = "steelblue") +
  tmap::tm_shape(lakes_site) + tm_fill ("steelblue") +
  tmap::tm_shape(watershed_site) + tm_borders(col = "red", lwd=1)
```

```{r watershed-inputs-deprecated}
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| comment: NA
#
## 2. Download hydro data


#url_rivers <- "https://data.hydrosheds.org/file/HydroRIVERS/HydroRIVERS_v10_shp.zip"
#url_lakes <- "https://data.hydrosheds.org/file/hydrolakes/HydroLAKES_polys_v10_shp.zip"
#url_watersheds <- "https://data.hydrosheds.org/file/hydrobasins/customized_with_lakes/hybas_lake_af_lev01-12_v1c.zip"
# download.file(url = url, path = getwd(), destfile = file_name)

rivers   = terra::vect("../assets/inputs/hydro/HydroRIVERS_v10.shp") 
lakes    = terra::vect("../assets/inputs/hydro/HydroLAKES_polys_v10.shp") 
watershed= terra::vect("../assets/inputs/hydro/hybas_lake_af_lev04_v1c.shp")

rivers_country = terra::crop(rivers, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
rivers_site = terra::crop(rivers, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

lakes_country = terra::crop(lakes, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
lakes_site = terra::crop(lakes, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

watershed_country = terra::crop(watershed, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
watershed_site = terra::crop(watershed, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

# save for faster runtime
sf::st_write(rivers_country, "../assets/inputs/rivers_country.shp")
sf::st_write(rivers_site, "../assets/inputs/rivers_site.shp")
sf::st_write(lakes_country, "../assets/inputs/lakes_country.shp")
sf::st_write(lakes_site, "../assets/inputs/lakes_site.shp")
sf::st_write(watershed_country, "../assets/inputs/watershed_country.shp")
sf::st_write(watershed_site, "../assets/inputs/watershed_site.shp")

#tmap::tm_shape(rivers_site) + tm_lines(col = "steelblue") +
#  tmap::tm_shape(lakes_site) + tm_fill ("steelblue") +
#  tmap::tm_shape(watershed_site) + tm_borders(col = "red", lwd=1)
```

```{r watershed-extracted-deprecated}
#| warning: false
#| message: false
#| echo: false
#| eval: false

rivers_country = sf::st_read("../assets/inputs/rivers_country.shp", quiet=T) |> st_cast("LINESTRING")
rivers_site    = sf::st_read("../assets/inputs/rivers_site.shp", quiet=T)    |> st_cast("LINESTRING")
lakes_country  = sf::st_read("../assets/inputs/lakes_country.shp", quiet=T)  |> st_cast("POLYGON")
lakes_site     = sf::st_read("../assets/inputs/lakes_site.shp", quiet=T)     |> st_cast("POLYGON")
watershed_site = sf::st_read("../assets/inputs/watershed_site.shp", quiet=T) |> st_cast("POLYGON")

#tmap::tm_shape(rivers_site) + tm_lines(col = "steelblue") +
#  tmap::tm_shape(lakes_site) + tm_fill ("steelblue") +
#  tmap::tm_shape(watershed_site) + tm_borders(col = "red", lwd=1)
##### Figure 2: Interactive map showing extracted hydrographic layers
```

```{r}
#| comment: NA
#| warning: false
#| message: false
#| eval: false
#| echo: true
crs_master = "EPSG:3005"
island_shoreline = sf::st_read("../assets/SHP/island_shoreline.shp", quiet=T)

# z = 12: 1-Arc Second 
# z = 11: 3-Arc Second 
# z = 10: 5-Arc Second 
dem_7arc = elevatr::get_elev_raster(island_shoreline, z=9,clip="locations")|>
  terra::rast()|> 
  terra::crop(terra::vect(island_shoreline)) |>  
  terra::project(crs_master)

#Process DEM by breaching & filling depressions & flats
dem_condt_7arc  = dem_7arc |> 
  flowdem::breach() |>
  flowdem::fill(epsilon=T) 
  #flowdem::fill_basins() # costal basins

# Calculate flow direction & accumulation
dem_dir_7arc = dem_condt_7arc |> flowdem::dirs(mode="d8")
dem_dir_5arc = dem_condt_5arc |> flowdem::dirs(mode="d8")
dem_acc_7arc = dem_dir_7arc |> flowdem::accum(mode="d8")
dem_acc_5arc = dem_dir_5arc |> flowdem::accum(mode="d8")

#tmap::tm_shape(dem) + 
#  tmap::tm_raster(
#    col.scale = tm_scale_continuous(values = "viridis"),
#    col.legend = tm_legend(title = "Elevation (m)", reverse = T)) + 
#  tmap::tm_graticules(lines = T, labels.rot = c(0, 90), lwd = 0.2) +
#  tmap::tm_scalebar(position = c("LEFT", "BOTTOM"), text.size = 0.5) + 
#  tmap::tm_compass(color.dark="gray60",text.color="gray60")+
#  tmap::tm_basemap("Esri.WorldImagery")
writeRaster(dem_condt_7arc, "../assets/TIF/dem_7arc_condt.tif", overwrite=T)
writeRaster(dem_condt_5arc, "../assets/TIF/dem_5arc_condt.tif", overwrite=T)
writeRaster(dem_dir_7arc, "../assets/TIF/dem_7arc_dir.tif", overwrite=T)
writeRaster(dem_dir_5arc, "../assets/TIF/dem_5arc_dir.tif", overwrite=T)
writeRaster(dem_acc_7arc, "../assets/TIF/dem_7arc_acc.tif", overwrite=T)
writeRaster(dem_acc_5arc, "../assets/TIF/dem_5arc_acc.tif", overwrite=T)
```

## 2.7 Build 3D map

```{r watershed-render}
#| warning: false
#| message: false
#| echo: true
#| eval: false
#| comment: NA

rivers_strahler = rivers_site |>
  dplyr::mutate(
    width = as.numeric(
      ORD_FLOW
    ),
    width = dplyr::case_when(
      width == 3 ~ 16,
      width == 4 ~ 14,
      width == 5 ~ 12,
      width == 6 ~ 10,
      width == 7 ~ 6,
      TRUE ~ 0
    )
  ) |>
  sf::st_as_sf() |>
  sf::st_transform(crs = "epsg:4326")

h <- nrow(dem_site)
w <- ncol(dem_site)

dem_matrix = rayshader::raster_to_matrix(dem_site)

dem_matrix |>
  rayshader:: height_shade() |>
  rayshader::add_overlay(
    rayshader::generate_line_overlay(
      geometry   = rivers_strahler,
      extent     = dem_site,
      heightmap  = dem_matrix,
      color      = "#387B9C",
      linewidth  = rivers_strahler$width,
      data_column_width = "width"
      ), alphalayer = 1
    ) |>
  rayshader::add_overlay(
    rayshader::generate_line_overlay(
      geometry   = lakes_site,
      extent     = dem_site,
      heightmap  = dem_matrix,
      color      = "#387B9C"
      ), alphalayer = 1
    ) |>
  rayshader::plot_3d(
    dem_matrix,
    zscale       = 14,
    solid        = T,
    shadow       = T,
    shadow_darkness = 2,
    background   = "white",
    windowsize   = c(600, 600),
    zoom         = 0.6,
    phi          = 40,
    theta        = 0 
  )
```

## 2.8 Render 3D map

```{r watershed-save}
#| eval: false

rayshader::render_highquality(
  preview        = T,
  light          = F,
  lightdirection = c(135, 45),
  lightcolor = c("white"),
  lightaltitude = 25,
  ambient_light = 0.1,
  rotate_env     = 0.4,
  intensity_env  = 0.85,
  interactive    = F,
  parallel       = T,
  width          = w,
  height         = h,
  backgroundhigh="#FFFFFF",
  backgroundlow="#FFFFFF"
  )
```

![Figure 4: Three-dimensional map of Lake Chilwa
watershed](https://raw.githubusercontent.com/seamusrobertmurphy/map-templates/refs/heads/main/assets/outputs/06-watershed-3D.png)

### Environment Setup

```{r}
#| warning: false
#| message: false
#| error: false
#| echo: true
#| eval: false
#| comment: NA
pacman::p_load(
  "bslib",
  "cli", "cols4all", "covr", "cowplot",
  "dendextend", "digest", "DiagrammeR", 
  "dtwclust", "downlit",
  "exactextractr", "elevatr",
  "FNN", "future", "flowdem",
  "gdalUtilities", "geojsonsf", "geos", "geodata", 
  "ggplot2", "ggstats","ggspatial", "ggmap", 
  "ggplotify", "ggpubr", "ggrepel", "giscoR",
  "hdf5r", "httr", "httr2", "htmltools",
  "jsonlite",
  "leafem", "leaflet.providers", "libgeos", 
  "luz", "lwgeom", "leaflet", "leafgl",
  "mapedit", "mapview", "maptiles", 
  "methods", "mgcv", "MPI",
  "ncdf4", "nnet",
  "openxlsx",
  "parallel", "plotly", "proj4", "PROJ", "progress", "purrr",
  "randomForest", "rasterVis", "raster", 
  "rayshader", "rayvertex", 
  "RColorBrewer", "rgl", "rmapshaper", "rsconnect", 
  "RStoolbox", "rts", "rgrass",
  "s2", "sf", "scales", "spdep", "stars", 
  "stringr", "supercells",
  "terra", "terrainr", "testthat", "traudem", "taudem", 
  "tidyverse", "tidyterra", "tools",
  "tmap", "tmaptools", "terrainr",
  "whitebox", "xgboost"
  )

# bleeding edge installs
#remotes::install_github("lucarraro/traudem", force=T)
#pak::pkg_install("MPI")
#devtools::install_github("lucarraro/traudem")
#remotes::install_github("opengeos/whiteboxR", build=F)
#remotes::install_github("giswqs/whiteboxR") 
#install.packages("easypackages")

# assign larger memory to tmap rendering
tmap::tmap_options(component.autoscale=F,
  max.raster = c(plot=9500000, view=10000000)
  )

# ----- Whitebox debugging ---- #
# whitebox doesnt like working with files in memory
# so we need to assign path to working directory 
# whitebox::install_whitebox() # install whitebox and GRASS libraries
whitebox::wbt_init() # activate whitebox library in current directory
list.files("/usr/local/taudem/") # Check traudem.pkg installation
# traudem::taudem_sitrep() # Check traudem dependencies
# Ignore above message "Can't find  `MoveOutletsToStrm`"

# ----- TauDEM d8 Check ---- #
# all(sapply(d8, file.exists))
# Expected result: [1] TRUE
# all(file.exists(unlist(d8)))
# Expected result: [1] TRUE
# all(map_lgl(d8, file.exists))
# Expected result: [1] TRUE
# can_register_taudem()
# Expected result: [1] TRUE
# Whitebox loaded tools: `print(wbt_list_tools())`
# Whitebox shortcuts : `print(wbt_help())`
# Whitebox version : `print(wbt_version())`
# Whitebox tool guide: `print(wbt_tool_help("lidar_info"))`\
# Whitebox parameter guide: `print(wbt_tool_parameters("slope"))`
mapviewOptions(fgb = FALSE)
sf::sf_use_s2(use_s2 = FALSE)
```

### Runtime Log

```{r session-info}
#| eval: true
devtools::session_info()
```

[^1]: <https://wiki.openstreetmap.org/wiki/Slippy_map>
