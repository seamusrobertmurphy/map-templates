---
title: "Watershed Maps"
execute:
  echo: true
format:
  html:
    toc: true
    toc-location: right
    highlight-style: pygments
    page-layout: article

editor_options: 
  markdown: 
    wrap: 60
---

```{r setup}
#| warning: false
#| message: false
#| include: false
#| error: false
#| echo: false
#| comment: NA

# bleeding edge installs first
#remotes::install_github("lucarraro/traudem", force=T)
#pak::pkg_install("MPI")
#devtools::install_github("lucarraro/traudem")
#remotes::install_github("opengeos/whiteboxR", build=F)
#remotes::install_github("giswqs/whiteboxR") # alternative repo

#install.packages("easypackages")
pacman::p_load(
  "bslib",
  "cli", "cols4all", "covr", "cowplot",
  "dendextend", "digest", "DiagrammeR", 
  "dtwclust", "downlit",
  "exactextractr", "elevatr",
  "FNN", "future", "flowdem",
  "gdalUtilities", "geojsonsf", "geos", "geodata", 
  "ggplot2", "ggstats","ggspatial", "ggmap", 
  "ggplotify", "ggpubr", "ggrepel", "giscoR",
  "hdf5r", "httr", "httr2", "htmltools",
  "jsonlite",
  "leafem", "leaflet.providers", "libgeos", 
  "luz", "lwgeom", "leaflet", "leafgl",
  "mapedit", "mapview", "maptiles", 
  "methods", "mgcv", "MPI",
  "ncdf4", "nnet",
  "openxlsx",
  "parallel", "plotly", "proj4", "PROJ", "progress", "purrr",
  "randomForest", "rasterVis", "raster",
  "rayshader", "rayvertex", 
  "RColorBrewer", "rgl", "rsconnect", 
  "RStoolbox", "rts", "rgrass",
  "s2", "sf", "scales", "spdep", "stars", 
  "stringr", "supercells",
  "terra", "terrainr", "testthat", "traudem", "taudem", 
  "tidyverse", "tidyterra", "tools",
  "tmap", "tmaptools", "terrainr",
  "whitebox", "xgboost"
  )

knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE, 
  warning = FALSE,
  error = FALSE, 
  comment = NA, 
  tidy.opts = list(width.cutoff = 60)
  ) 

options(
  htmltools.dir.version = FALSE, 
  htmltools.preserve.raw = FALSE)

tmap::tmap_options(component.autoscale=F,
  max.raster = c(plot=9500000, view=10000000)
  )

# whitebox doesnt like working with files in memory
# so we need to assign path to working directory 
#whitebox::install_whitebox() # install whitebox and GRASS libraries
whitebox::wbt_init() # activate whitebox library in current directory
traudem::taudem_sitrep() # Check traudem dependencies
list.files("/usr/local/taudem/") # Check traudem.pkg installation

# ----- TauDEM d8 Check ---- #
# all(sapply(d8, file.exists))
# Expected result: [1] TRUE
# all(file.exists(unlist(d8)))
# Expected result: [1] TRUE
# all(map_lgl(d8, file.exists))
# Expected result: [1] TRUE
# can_register_taudem()
# Expected result: [1] TRUE
# Whitebox loaded tools: `print(wbt_list_tools())`
# Whitebox shortcuts : `print(wbt_help())`
# Whitebox version : `print(wbt_version())`
# Whitebox tool guide: `print(wbt_tool_help("lidar_info"))`\
# Whitebox parameter guide: `print(wbt_tool_parameters("slope"))`
mapviewOptions(fgb = FALSE)
sf::sf_use_s2(use_s2 = FALSE)
```

```{css, echo=FALSE, class.source = 'foldable'}
div.column {
    display: inline-block;
    vertical-align: top;
    width: 50%;
}

#TOC::before {
  content: "";
  display: block;
  height:200px;
  width: 200px;
  background-image: url('https://raw.githubusercontent.com/seamusrobertmurphy/map-templates/refs/heads/main/assets/outputs/06-watershed-3D.png');
  background-size: contain;
  background-position: 50% 50%;
  padding-top: 80px !important;
  background-repeat: no-repeat;
}
```

## 2.0 Overview

This analysis performs geomorphological processing of
digital elevation models (DEMs) to extract critical
watershed characteristics needed for hydrological modeling.
We implement two complementary workflows for watershed
delineation and hydraulic network analysis, comparing
approaches using the `flowdem` and `whitebox` packages
deploying `RichDEM`, `GDAL 3.11`, and `r-spatial` libraries.

## 2.1 Declare AOI & Projection

```{r pop-aoi}
#| warning: false
#| message: false
#| error: false
#| echo: true
#| eval: true
#| comment: NA

crs_master = sf::st_crs("EPSG:3857")

country = giscoR::gisco_get_countries(
  country = "Malawi", resolution = "3") |>
  sf::st_cast() |> sf::st_transform(crs_master)

lake  = sf::st_read("./assets/inputs/lakes_site.shp", quiet=T) |>
  sf::st_cast() |> sf::st_transform(crs_master)

bbox = lake |>
  sf::st_buffer(dist = 60000) |> 
  sf::st_bbox() |>
  sf::st_as_sfc() |>
  sf::st_sf()

# Interactive map mode: "view"
tmap::tmap_mode("view")
tmap::tm_shape(country) + tmap::tm_borders(lwd = 1, col = "green") +
  tmap::tm_shape(bbox) + tmap::tm_borders(lwd = 2, col = "orange") +
  tmap::tm_shape(lake) + tmap::tm_borders(lwd = 2, col = "blue") +
  tmap::tm_basemap("Esri.WorldImagery")
```

##### Figure 1: Interactive map of area of interest polygons (AOI)

## 2. Process DEM

```{r watershed-dem}
#| warning: false
#| message: false
#| error: false
#| eval: false
#| echo: true
#| comment: NA

# z = 12: 1-Arc Second Resolution
# z = 11: 3-Arc Second Resolution
# z = 10: 5-Arc Second Resolution
dem = elevatr::get_elev_raster(bbox, z=10, clip="locations") |> terra::rast() 
names(dem) = "elevation" 

dem_100m  = stars::st_warp(
  stars::st_as_stars(dem), 
  cellsize=100, crs=sf::st_crs(crs_master)) |>
  terra::rast()

# Apply breaching & filling to depressions & flats
dem_breach = flowdem::breach(dem_100m) 
dem_fill   = flowdem::fill(dem_breach, epsilon=T)  
#flowdem::fill_basins() # coastal basins

# Calculate flow direction & flow accumulation
dem_dir =  flowdem::dirs(dem_fill, mode="d8")
dem_acc =  flowdem::dirs(dem_dir, mode="d8")

# Delineate watershed drainage area
watershed = flowdem::watershed(dem_dir, lake) |>
  terra::as.polygons(dissolve = TRUE) |>
  sf::st_as_sf()

# Save elevation models to local directory
#terra::writeRaster(dem_100m,  "./assets/TIF/dem_chilwa_00_raw.tif",overwrite=T)
#terra::writeRaster(dem_breach, "./assets/TIF/dem_chilwa_01_breached.tif",overwrite=T)
#terra::writeRaster(dem_fill, "./assets/TIF/dem_chilwa_02_filled.tif",overwrite=T)
#terra::writeRaster(dem_dir, "./assets/TIF/dem_chilwa_03_flow_direction.tif",overwrite=T)
#terra::writeRaster(dem_acc, "./assets/TIF/dem_chilwa_04_flow_accumulation.tif",overwrite=T)
#sf::st_write(watershed, "./assets/SHP/watershed_chilwa_05_flowdem.shp", delete_dsn=T)

# Visualize effects of hydrographic conditioning
dem_breach_diff <- dem_100m - dem_breach
dem_breach_diff[dem_breach_diff == 0] <- NA
dem_fill_diff <- dem_100m - dem_fill
dem_fill_diff[dem_fill_diff == 0] <- NA

tmap::tmap_mode("plot")
tmap::tm_shape(dem_breach_diff) + tmap::tm_raster(col.scale = tm_scale_continuous(
    values = hcl.colors(50, rev = TRUE),midpoint = 0), col.legend = tm_legend(title="")) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_title("Effects of Breaching", size=.8) -> tm_breach

tmap::tm_shape(dem_fill_diff) + tmap::tm_raster(col.scale = tm_scale_continuous(
    values = hcl.colors(50, rev = TRUE),midpoint = 0), col.legend = tm_legend(title="")) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size = .5) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top")) +
  tmap::tm_graticules(lines=T,labels.rot=c(0,90),lwd=0.2) +
  tmap::tm_title("Effects of Filling", size=.8) -> tm_fill

tmap::tmap_arrange(tm_breach, tm_fill, nrow=1)
```

```{r watershed-dem-hidden}
#| warning: false
#| message: false
#| error: false
#| echo: false
#| eval: true
#| comment: NA
# Import outputs derived in chunk above
dem_100m   = terra::rast("./assets/TIF/dem_chilwa_00_raw.tif")
dem_breach = terra::rast("./assets/TIF/dem_chilwa_01_breached.tif")
dem_fill   = terra::rast("./assets/TIF/dem_chilwa_02_filled.tif")
```

![Figure 2: Static maps showing effects of hydraulic
conditioning essential to digital elevation
models](https://raw.githubusercontent.com/seamusrobertmurphy/map-templates/refs/heads/main/_site/watershed-map_files/figure-html/watershed-dem-1.png){fig-align="center"}

```{r}
#| eval: false
whitebox::wbt_breach_depressions(
  dem   = "dem_chilwa_00_raw.tif",
  output= "dem_chilwa_11_breached.tif",
  wd    = "./assets/TIF/",
  max_depth = 50,  # Only breach small features, not the lake
  flat_increment = 0.001
  )

whitebox::wbt_fill_depressions(
  dem    = "dem_chilwa_11_breached.tif",
  output = "dem_chilwa_12_filled.tif",
  wd     = "./assets/TIF/",
  fix_flats = T,
  flat_increment = 0.001,
  max_depth = 10  # This preserves larger depressions such as lake
  )

whitebox::wbt_d8_pointer(
  dem   = "dem_chilwa_12_filled.tif",
  output= "dem_chilwa_13_flow_direction.tif",
  wd    = "./assets/TIF/"
  )

whitebox::wbt_d8_flow_accumulation(
  input = "dem_chilwa_13_flow_direction.tif", pntr = T,
  output= "dem_chilwa_14_flow_accumulation.tif",
  wd    = "./assets/TIF/"
  )

whitebox::wbt_extract_streams(
  flow_accum= "dem_chilwa_14_flow_accumulation.tif", # accumulation input
  threshold = 100, # should align with 1km2 resolution applied upstream
  output    = "dem_chilwa_15_streams_gridded.tif",
  wd        = "./assets/TIF/", 
  zero_background = T 
  )

whitebox::wbt_remove_short_streams(
  d8_pntr   = "dem_chilwa_13_flow_direction.tif",  # flow direction
  streams   = "dem_chilwa_15_streams_gridded.tif",
  output    = "dem_chilwa_16_streams_d8.tif",
  min_length= 200,
  wd        = "./assets/TIF/"
  )

# ----------- Drainage Terminus -------------- #
# Create multiple pour points around Lake Chilwa
# (northern edge, southern edge, eastern edge, western edge)
# Usually, all we need to do is select a terminal flow point 
# in areas of lowest elevation and highest flow accumulation.

# Whitebox tools expect exorheic watersheds as inputs, as most 
# hydrology algorithms compute drainage areas from downstream 
# flow points where water is seen exiting the drainage basin. 
# However, Lake Chilwa is an endorheic lake with zero exit.

# We list three solutions below, but caution that these methods 
# and endorheic drainages in general call for additional testing,
# case-by-case analysis. Simplest solution is augment the flow sample
# with additional terminus locations marking wider extent of lowest 
# drainage area. A slightly more rigorous yet efficient alternative 
# is possible by delineating all sub-basins within and mapping outwards.
# The third, methodologically sound option is provided using a hydraulic 
# algorithm that is tailored specifically for endorheic depressions.

# Derive point shapefile(s) of terminal point near high flow accumulation
outlets = editMap(mapview(dem_acc)) 
outlets = outlets$all |> # convert to sf
  sf::st_transform(crs_master) |>
  dplyr::select(geometry)
outlets$id <- "chilwa_drainage_terminus"

# Create multiple terminal flow points to improve delineation
outlets_add = editMap(mapview(dem_acc)) 
outlets_add = outlets_add$all |> # convert to sf
  sf::st_transform(crs_master) |>
  dplyr::select(geometry)
outlets_add$id <- "chilwa_drainage_terminus_multiple"

# Save terminal flow points for reproducibility
sf::st_write(outlets, "./assets/SHP/outlets.shp", delete_layer=T, quiet=T)
sf::st_write(outlets_add, "./assets/SHP/outlets_multiple.shp", delete_layer=T)

# Delineate watershed from flow terminus and flow direction 
whitebox::wbt_watershed(
  d8_pntr = "dem_chilwa_13_flow_direction.tif",
  pour_pts = "./assets/SHP/outlets_multiple.shp",
  output = "dem_chilwa_17_watershed.tif",
  wd = "./assets/TIF/"
)

# Delineate regional watersheds and extract endorheic sub-basin manually
whitebox::wbt_basins(
  d8_pntr = "dem_chilwa_13_flow_direction.tif",
  output = "dem_chilwa_18_basins.tif",
  wd = "./assets/TIF/"
)

# Recmmended algorithm for endorheic drainages
whitebox::wbt_stochastic_depression_analysis(
  dem = "dem_chilwa_00_raw.tif",
  output = "dem_chilwa_19_depressions.tif",
  rmse = 5.0,  # Root mean square error in elevation units
  range = 100,  # Range parameter
  iterations = 100,
  wd = "./assets/TIF/"
)



# Visual check
tmap::tmap_mode("view")
tmap::tm_shape(dem_acc) + tmap::tm_raster() +
  tmap::tm_shape(outlets_sf) + tmap::tm_symbols(shape="id",lwd=2)

tmap::tm_shape(dem_filled) + tmap::tm_raster() + 
  tmap::tm_shape(outlets_sf) + tmap::tm_symbols(shape="id",lwd=2)
 
# Create binary mask; Values > 0 represent the endorheic basin
depressions = terra::rast("./assets/TIF/dem_chilwa_19_depressions.tif")

# Due to its shallow depths, we need to derive suitable thresholds 
depth_threshold <- 10  # meters 
depression_major <- depressions > depth_threshold
depression_polygons <- as.polygons(depressions_major, dissolve = FALSE) |> 
  st_as_sf()
plot(depressions_polyons)

# Calculate area of watershed depression polygon
depression_polygons$area_km2 <- as.numeric(st_area(depression_polygons)) / 1e6

# Keep only the LARGEST depression (Lake Chilwa)
chilwa_basin <- depression_polygons[which.max(depression_polygons$area_km2), ]

# Visualize
plot(st_geometry(chilwa_basin), 
     main = "Lake Chilwa Main Depression",
     col = "lightblue",
     border = "red",
     lwd = 2)

print(paste("Basin area:", round(chilwa_basin$area_km2, 1), "km²"))

drainage  = stars::read_stars("./assets/TIF/dem_chilwa_17_watershed.tif")
watershed = stars::st_contour(drainage, breaks = 1) |> 
  sf::st_geometry() |> 
  sf::st_cast("POLYGON")

watershed_bdry <- watershed[which.max(st_area(watershed))]

```

##### Figure 2: Interactive maps of hydrographically conditioned and unconditioned digital elevation models.

```{r}
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| comment: NA

watershed= terra::vect("./assets/inputs/hydro/hybas_lake_af_lev04_v1c.shp")
rivers   = terra::vect("./assets/inputs/hydro/HydroRIVERS_v10.shp") 

rivers_country = terra::crop(rivers, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
rivers_site = terra::crop(rivers, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

lakes_country = terra::crop(lakes, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
lakes_site = terra::crop(lakes, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

aoi_site   = sf::read_sf("./assets/inputs/chilwa_watershed_4326.shp") |>
  st_cast() |> st_transform(crs_master)
aoi_country <- giscoR::gisco_get_countries(country = "Malawi", resolution = "3") |>
  st_cast() |>
  st_transform(crs_master)

# Interactive map mode: "view"
tmap::tmap_mode("view")
tmap::tm_shape(aoi_country) +
  tmap::tm_borders(lwd = 1, col = "green") +
  tmap::tm_shape(aoi_site) +
  tmap::tm_borders(lwd = 2, col = "red")

tmap::tm_shape(dem_site) + tmap::tm_raster(palette = "Greens") +
  tmap::tm_shape(rivers_site) + tm_lines(col = "steelblue") +
  tmap::tm_shape(lakes_site) + tm_fill ("steelblue") +
  tmap::tm_shape(watershed_site) + tm_borders(col = "red", lwd=1)
```

```{r watershed-inputs-deprecated}
#| warning: false
#| message: false
#| echo: false
#| eval: false
#| comment: NA
#
## 2. Download hydro data


#url_rivers <- "https://data.hydrosheds.org/file/HydroRIVERS/HydroRIVERS_v10_shp.zip"
#url_lakes <- "https://data.hydrosheds.org/file/hydrolakes/HydroLAKES_polys_v10_shp.zip"
#url_watersheds <- "https://data.hydrosheds.org/file/hydrobasins/customized_with_lakes/hybas_lake_af_lev01-12_v1c.zip"
# download.file(url = url, path = getwd(), destfile = file_name)

rivers   = terra::vect("./assets/inputs/hydro/HydroRIVERS_v10.shp") 
lakes    = terra::vect("./assets/inputs/hydro/HydroLAKES_polys_v10.shp") 
watershed= terra::vect("./assets/inputs/hydro/hybas_lake_af_lev04_v1c.shp")

rivers_country = terra::crop(rivers, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
rivers_site = terra::crop(rivers, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

lakes_country = terra::crop(lakes, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
lakes_site = terra::crop(lakes, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

watershed_country = terra::crop(watershed, aoi_country) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)
watershed_site = terra::crop(watershed, aoi_site) |> 
  sf::st_as_sf() |> sf::st_cast() |> sf::st_transform(crs_master)

# save for faster runtime
sf::st_write(rivers_country, "./assets/inputs/rivers_country.shp")
sf::st_write(rivers_site, "./assets/inputs/rivers_site.shp")
sf::st_write(lakes_country, "./assets/inputs/lakes_country.shp")
sf::st_write(lakes_site, "./assets/inputs/lakes_site.shp")
sf::st_write(watershed_country, "./assets/inputs/watershed_country.shp")
sf::st_write(watershed_site, "./assets/inputs/watershed_site.shp")

#tmap::tm_shape(rivers_site) + tm_lines(col = "steelblue") +
#  tmap::tm_shape(lakes_site) + tm_fill ("steelblue") +
#  tmap::tm_shape(watershed_site) + tm_borders(col = "red", lwd=1)
```

```{r watershed-extracted-deprecated}
#| warning: false
#| message: false
#| echo: false
#| eval: false

rivers_country = sf::st_read("./assets/inputs/rivers_country.shp", quiet=T) |> st_cast("LINESTRING")
rivers_site    = sf::st_read("./assets/inputs/rivers_site.shp", quiet=T)    |> st_cast("LINESTRING")
lakes_country  = sf::st_read("./assets/inputs/lakes_country.shp", quiet=T)  |> st_cast("POLYGON")
lakes_site     = sf::st_read("./assets/inputs/lakes_site.shp", quiet=T)     |> st_cast("POLYGON")
watershed_site = sf::st_read("./assets/inputs/watershed_site.shp", quiet=T) |> st_cast("POLYGON")

#tmap::tm_shape(rivers_site) + tm_lines(col = "steelblue") +
#  tmap::tm_shape(lakes_site) + tm_fill ("steelblue") +
#  tmap::tm_shape(watershed_site) + tm_borders(col = "red", lwd=1)
##### Figure 2: Interactive map showing extracted hydrographic layers
```

## 2. Process DEM

**Note:** More efficient conditioning algorithms available
with `RichDEM` library \[\^1\]

```{r}
#| comment: NA
#| warning: false
#| message: false
#| eval: false
#| echo: true
crs_master = "EPSG:3005"
island_shoreline = sf::st_read("./assets/SHP/island_shoreline.shp", quiet=T)

# z = 12: 1-Arc Second 
# z = 11: 3-Arc Second 
# z = 10: 5-Arc Second 
dem_7arc = elevatr::get_elev_raster(island_shoreline, z=9,clip="locations")|>
  terra::rast()|> 
  terra::crop(terra::vect(island_shoreline)) |>  
  terra::project(crs_master)

#Process DEM by breaching & filling depressions & flats
dem_condt_7arc  = dem_7arc |> 
  flowdem::breach() |>
  flowdem::fill(epsilon=T) 
  #flowdem::fill_basins() # costal basins

# Calculate flow direction & accumulation
dem_dir_7arc = dem_condt_7arc |> flowdem::dirs(mode="d8")
dem_dir_5arc = dem_condt_5arc |> flowdem::dirs(mode="d8")
dem_acc_7arc = dem_dir_7arc |> flowdem::accum(mode="d8")
dem_acc_5arc = dem_dir_5arc |> flowdem::accum(mode="d8")

#tmap::tm_shape(dem) + 
#  tmap::tm_raster(
#    col.scale = tm_scale_continuous(values = "viridis"),
#    col.legend = tm_legend(title = "Elevation (m)", reverse = T)) + 
#  tmap::tm_graticules(lines = T, labels.rot = c(0, 90), lwd = 0.2) +
#  tmap::tm_scalebar(position = c("LEFT", "BOTTOM"), text.size = 0.5) + 
#  tmap::tm_compass(color.dark="gray60",text.color="gray60")+
#  tmap::tm_basemap("Esri.WorldImagery")
writeRaster(dem_condt_7arc, "./assets/TIF/dem_7arc_condt.tif", overwrite=T)
writeRaster(dem_condt_5arc, "./assets/TIF/dem_5arc_condt.tif", overwrite=T)
writeRaster(dem_dir_7arc, "./assets/TIF/dem_7arc_dir.tif", overwrite=T)
writeRaster(dem_dir_5arc, "./assets/TIF/dem_5arc_dir.tif", overwrite=T)
writeRaster(dem_acc_7arc, "./assets/TIF/dem_7arc_acc.tif", overwrite=T)
writeRaster(dem_acc_5arc, "./assets/TIF/dem_5arc_acc.tif", overwrite=T)
```

## 4. Build 3D map

```{r watershed-render}
#| warning: false
#| message: false
#| echo: true
#| eval: false
#| comment: NA

rivers_strahler = rivers_site |>
  dplyr::mutate(
    width = as.numeric(
      ORD_FLOW
    ),
    width = dplyr::case_when(
      width == 3 ~ 16,
      width == 4 ~ 14,
      width == 5 ~ 12,
      width == 6 ~ 10,
      width == 7 ~ 6,
      TRUE ~ 0
    )
  ) |>
  sf::st_as_sf() |>
  sf::st_transform(crs = "epsg:4326")

h <- nrow(dem_site)
w <- ncol(dem_site)

dem_matrix = rayshader::raster_to_matrix(dem_site)

dem_matrix |>
  rayshader:: height_shade() |>
  rayshader::add_overlay(
    rayshader::generate_line_overlay(
      geometry   = rivers_strahler,
      extent     = dem_site,
      heightmap  = dem_matrix,
      color      = "#387B9C",
      linewidth  = rivers_strahler$width,
      data_column_width = "width"
      ), alphalayer = 1
    ) |>
  rayshader::add_overlay(
    rayshader::generate_line_overlay(
      geometry   = lakes_site,
      extent     = dem_site,
      heightmap  = dem_matrix,
      color      = "#387B9C"
      ), alphalayer = 1
    ) |>
  rayshader::plot_3d(
    dem_matrix,
    zscale       = 14,
    solid        = T,
    shadow       = T,
    shadow_darkness = 2,
    background   = "white",
    windowsize   = c(600, 600),
    zoom         = 0.6,
    phi          = 40,
    theta        = 0 
  )
```

## 5. Render 3D map

```{r watershed-save}
#| eval: false

rayshader::render_highquality(
  preview        = T,
  light          = F,
  lightdirection = c(135, 45),
  lightcolor = c("white"),
  lightaltitude = 25,
  ambient_light = 0.1,
  rotate_env     = 0.4,
  intensity_env  = 0.85,
  interactive    = F,
  parallel       = T,
  width          = w,
  height         = h,
  backgroundhigh="#FFFFFF",
  backgroundlow="#FFFFFF"
  )
```

![Figure 4: Three-dimensional map of Lake Chilwa
watershed](https://raw.githubusercontent.com/seamusrobertmurphy/map-templates/refs/heads/main/assets/outputs/06-watershed-3D.png)

```{r session-info}
#| eval: true
devtools::session_info()
```
