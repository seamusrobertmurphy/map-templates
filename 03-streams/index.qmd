---
title: "Streams"
execute:
  echo: true
format:
  html:
    toc: true
    toc-location: right
    toc-depth: 4
    toc-title: "**On this page**"
    number-sections: false
    highlight-style: pygments
    page-layout: article

editor_options: 
  markdown: 
    wrap: 60
---

## 3.0 Overview

### Environment Setup

```{r setup}
#| warning: false
#| message: false
#| echo: true
#| comment: NA
pacman::p_load(
  "cli", "cols4all", "covr", "cowplot",
  "dendextend", "digest", "DiagrammeR", "dtwclust", "downlit",
  "exactextractr", "elevatr",
  "FNN", "future", "flowdem",
  "gdalUtilities", "geojsonsf", "geos", "geodata", 
  "ggplot2", "ggstats","ggspatial", "ggmap", 
  "ggplotify", "ggpubr", "ggrepel", "giscoR",
  "hdf5r", "httr", "httr2", "htmltools",
  "jsonlite",
  "leafem", "leaflet.providers", "libgeos", "luz", "lwgeom", "leaflet", "leafgl",
  "mapedit", "mapview", "maptiles", "methods", "mgcv",
  "ncdf4", "nnet",
  "openxlsx",
  "parallel", "plotly", "proj4", "PROJ",
  "randomForest", "rasterVis", "raster",
  "rayshader", "rayvertex", 
  "RColorBrewer", "rgl", "rsconnect", "RStoolbox", "rts",
  "s2", "sf", "scales", "spdep", "stars", "stringr", "supercells",
  "terra", "testthat", "tidyverse", "tidyterra", "tools",
  "tmap", "tmaptools", "terrainr",
  "xgboost"
)
```

```{r}
#| warning: false
#| message: false
#| include: false
#| echo: false
#| comment: NA

knitr::opts_chunk$set(
  echo    = T, 
  error   = F, 
  message = F, 
  warning = F,
  comment = NA, 
  tidy.opts = list(
    width.cutoff = 60)
  )

options(
  htmltools.dir.version = F, 
  htmltools.preserve.raw = F)

tmap::tmap_options(
  component.autoscale=F,
  max.raster = c(plot=9500000, view=10000000)
  )

mapviewOptions(fgb = FALSE)
sf::sf_use_s2(use_s2 = FALSE)
```

```{css, echo=FALSE, class.source = 'foldable'}
div.column {
    display: inline-block;
    vertical-align: top;
    width: 50%;
}

#TOC::before {
  content: "";
  display: block;
  height:200px;
  width: 200px;
  background-image: url('https://raw.githubusercontent.com/seamusrobertmurphy/map-templates/refs/heads/main/assets/MAP/stream_map_high_b.png');
  background-size: contain;
  background-position: 50% 50%;
  padding-top: 80px !important;
  background-repeat: no-repeat;
}
```

## 3.1 Import AOI

```{r aoi-import}
#| warning: false
#| message: false
#| echo: true
#| eval: false
#| comment: NA
library(sf)

aoi_00 = geodata::gadm(
  country="CAN", level=0, 
  path="./assets/SHP/") |> 
  sf::st_as_sf()

aoi_01  = geodata::gadm(
  country="CAN", level=1, 
  path="../assets/SHP/") |> 
  sf::st_as_sf()

aoi_02  = geodata::gadm(
  country="CAN", level=2, 
  path="../assets/SHP/") |> 
  sf::st_as_sf()

aoi_03  = geodata::gadm(
  country="CAN", level=3, 
  path="../assets/SHP/") |> 
  sf::st_as_sf()

# ------------ #
# BC Albers    #
# ------------ #
crs_master = "EPSG:3005"
sf::st_transform(aoi_00, crs_master)
sf::st_transform(aoi_01, crs_master)
sf::st_transform(aoi_02, crs_master)
sf::st_transform(aoi_03, crs_master)

sf::st_write(aoi_00, "../assets/SHP/aoi_00.shp", delete_dsn = T)
sf::st_write(aoi_01, "../assets/SHP/aoi_01.shp", delete_dsn = T)
sf::st_write(aoi_02, "../assets/SHP/aoi_02.shp", delete_dsn = T)
sf::st_write(aoi_03, "../assets/SHP/aoi_03.shp", delete_dsn = T)
```

## 3.2 Extract Shoreline

```{r aoi-extract}
#| warning: false
#| message: false
#| echo: true
#| eval: false
#| comment: NA
bc_province = sf::st_read("../assets/SHP/aoi_01.shp", quiet=T) |>
  sf::st_make_valid() |> dplyr::filter(NAME_1 == "British Columbia") 
bc_districts = sf::st_read("../assets/SHP/aoi_02.shp", quiet=T)|>
  sf::st_make_valid() |> dplyr::filter(NAME_1 == "British Columbia")
bc_counties = sf::st_read("../assets/SHP/aoi_03.shp", quiet=T)|>
  sf::st_make_valid() |> dplyr::filter(NAME_1 == "British Columbia")

# ---------------------------  #
# Note: BBOX needs CRS forcing #
island_extent = sf::st_bbox(c(
  xmin = -129.5, ymin = 48.1, 
  xmax = -123.0, ymax = 51.0), 
  crs = st_crs(4326)) |> 
  sf::st_as_sfc()
island_extent_sf = sf::st_as_sf(island_extent) 

shoreline_input <- osmdata::opq(bbox = sf::st_bbox(island_extent_sf)) |>
  osmdata::add_osm_feature(key = "natural", value = "coastline") |>
  osmdata::osmdata_sf() |> {\(x) x$osm_lines}() |>
  sf::st_intersection(island_extent_sf) |>
  sf::st_union() |>
  sf::st_polygonize() |>
  sf::st_collection_extract("POLYGON")

# `rmapshaper::ms_clip()` requires perimiter polygon shell only
shoreline_shell <- shoreline_input %>%
  sf::st_union() %>%
  sf::st_as_sf()|> 
  sf::st_transform(crs_master)

island_shoreline <- bc_districts %>%
  sf::st_filter(shoreline_input, .predicate = st_intersects) %>%
  rmapshaper::ms_dissolve() %>% 
  rmapshaper::ms_clip(shoreline_shell)|> 
  sf::st_transform(crs_master)

island_districts <- bc_districts %>%
  sf::st_filter(shoreline_input, .predicate = st_intersects) %>%
  rmapshaper::ms_simplify(keep = 0.95) %>%        
  rmapshaper::ms_clip(shoreline_shell)|> 
  sf::st_transform(crs_master)             

island_counties <- bc_counties %>%
  sf::st_filter(shoreline_input, .predicate = st_intersects) %>%
  rmapshaper::ms_simplify(keep = 0.95) %>%        
  rmapshaper::ms_clip(shoreline_shell)|> 
  sf::st_transform(crs_master)             

sf::st_write(island_districts, "../assets/SHP/island_districts.shp", delete_dsn=T)
sf::st_write(island_counties, "../assets/SHP/island_counties.shp", delete_dsn=T)
sf::st_write(island_shoreline, "../assets/SHP/island_shoreline.shp", delete_dsn=T)
sf::st_write(shoreline_input, "../assets/SHP/shoreline_input.shp", delete_dsn=T)
sf::st_write(shoreline_shell, "../assets/SHP/shoreline_shell.shp", delete_dsn=T)

tmap::tmap_mode("view")
tmap::tm_shape(island_counties) + tm_borders(lwd=0) +
  tmap::tm_shape(island_shoreline) + tm_borders(col = "black", lwd=4) +
  tmap::tm_shape(island_districts) + tm_borders(col = "purple", lwd=1.5) +
  tmap::tm_shape(island_counties) + tm_borders(col = "yellow", lwd=0.5) +
  tmap::tm_basemap("Esri.WorldImagery") -> tm01_live
tm01_live
```

```{r aoi-render}
#| warning: false
#| message: false
#| error: false
#| echo: false
#| eval: true
#| comment: NA
crs_master = "EPSG:3005"
island_districts = sf::st_read("../assets/SHP/island_districts.shp", quiet=T)|> 
  sf::st_transform(crs_master)
island_counties  = sf::st_read("../assets/SHP/island_counties.shp", quiet=T)|> 
  sf::st_transform(crs_master) 
island_shoreline = sf::st_read("../assets/SHP/island_shoreline.shp", quiet=T)|> 
  sf::st_transform(crs_master)
shoreline_input  = sf::st_read("../assets/SHP/shoreline_input.shp", quiet=T)|> 
  sf::st_transform(crs_master)
shoreline_shell  = sf::st_read("../assets/SHP/shoreline_shell.shp", quiet=T)|> 
  sf::st_transform(crs_master)

tmap::tmap_mode("view")
tmap::tm_shape(island_counties) + tm_borders(lwd=0) +
  tmap::tm_shape(island_shoreline) + tm_borders(col = "black", lwd=4) +
  tmap::tm_shape(island_districts) + tm_borders(col = "purple", lwd=1.5) +
  tmap::tm_shape(island_counties) + tm_borders(col = "yellow", lwd=0.5) +
  tmap::tm_basemap("Esri.WorldImagery")  -> tm01_live
tm01_live
```

Figure 3a Interactive map of delineated shoreline and
administrative boundaries

```{r basemap-save}
#| comment: NA
#| message: false
#| warning: false
#| error: false
#| eval: false
#| echo: false
library(maptiles)
library(basemaps)
library(leaflet)
library(leaflet.providers)

# ------------------------------------------- #
# Saving basemap to accelerate downstream     #
# ------------------------------------------- #
basemap_500k = maptiles::get_tiles(island_districts, zoom=10, 
  crop = T,provider="Esri.WorldStreetMap",project=T,verbose=T)|> 
  terra::project(crs_master)

basemap_250k = maptiles::get_tiles(island_districts, zoom = 11,
  crop = T,provider = "OpenStreetMap",project=T, verbose = T)|> 
  terra::project(crs_master)

basemap_150k = maptiles::get_tiles(island_districts, zoom=12, 
  crop= T,provider="Esri.WorldStreetMap",project=T,verbose=T)|> 
  terra::project(crs_master)

basemap_70k = maptiles::get_tiles(island_districts, zoom=13, 
  crop= T,provider="Esri.WorldStreetMap",project=T,verbose=T)|> 
  terra::project(crs_master)

writeRaster(basemap_70k, "../assets/TIF/basemap_70k.tif", overwrite=T)
writeRaster(basemap_150k, "../assets/TIF/basemap_150k.tif", overwrite=T)
writeRaster(basemap_250k, "../assets/TIF/basemap_250k.tif", overwrite=T)
writeRaster(basemap_500k, "../assets/TIF/basemap_500k.tif", overwrite=T)

# Static Map  #
tmap::tmap_mode("view")
tmap::tm_shape(island_counties) + tmap::tm_borders(lwd=0) +  
  tmap::tm_shape(basemap_150k) + tmap::tm_rgb() +
  tmap::tm_shape(island_districts) + tmap::tm_borders(col = "turquoise", lwd=1.2) +
  tmap::tm_shape(island_counties) + tmap::tm_borders(col = "purple", lwd=0.8) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size=.5) +
  tmap::tm_compass(color.dark="gray60",position=c("RIGHT", "top"))+
  tmap::tm_credits(text="EPSG:3005",color="gray60",size=.5,position=c("left","BOTTOM")) +
  tmap::tm_layout(
    main.title = "Island Shoreline Delineation",
    title.position  = ("top"),
    legend.position = c("left", "bottom") -> tm02_static
  
tmap::tmap_save(tm01, "../assets/MAP/09-shoreline-map.png")
tm02_static
```

```{r basemap-render}
#| layout-ncol: 1
#| message: false
#| warning: false
#| comment: NA
#| error: false
#| eval: false
#| echo: false

#basemap_70k = terra::rast("../assets/TIF/basemap_70k.tif")
basemap_150k = terra::rast("../assets/TIF/basemap_150k.tif")
#basemap_250k = terra::rast("../assets/TIF/basemap_250k.tif")
#basemap_500k = terra::rast("../assets/TIF/basemap_500k.tif")

tmap::tmap_mode("view")
tmap::tm_shape(island_counties) + tmap::tm_borders(lwd=0) +  # framing placeholder
  tmap::tm_shape(basemap_150k) +  tmap::tm_rgb() +
  tmap::tm_shape(island_districts) + tmap::tm_borders(col = "turquoise", lwd=1.2) +
  tmap::tm_shape(island_counties) +  tmap::tm_borders(col = "purple", lwd=0.8) +
  tmap::tm_scalebar(position=c("RIGHT", "BOTTOM"), text.size=.5) +
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("RIGHT", "top"))+
  tmap::tm_credits(text="EPSG:3005",color="gray60",size=.5,position=c("left","BOTTOM"))+
  tmap::tm_layout(
    main.title        = "Shoreline Delineation (1:150,000)",
    title.position    = ("top"),
    legend.position   = c("left", "bottom"),
    legend.text.size  = 0.9,
    legend.title.size = 0.9
    ) -> tm03_live
tm03_live
```

## 3.3 Process DEM

Additional conditioning algorithms are available within the
`RichDEM` library [^index-1]

```{r}
#| comment: NA
#| warning: false
#| message: false
#| eval: false
#| echo: true
# Inputs
island_shoreline = sf::st_read("../assets/SHP/island_shoreline.shp", quiet=T)
dem_7arc = elevatr::get_elev_raster(island_shoreline, z=9,clip="locations")|>
  terra::rast()|> 
  terra::crop(terra::vect(island_shoreline)) |>  
  terra::project(crs_master)

# Apply breaching & filling algorithms
dem_condt_7arc  = dem_7arc |> 
  flowdem::breach() |>
  flowdem::fill(epsilon=T) |>
  flowdem::fill_basins() # costal basins

# Calculate flow direction & accumulation
dem_dir_7arc = dem_condt_7arc |> flowdem::dirs(mode="d8")
dem_acc_7arc = dem_dir_7arc |> flowdem::accum(mode="d8")

tmap::tm_shape(dem) + 
  tmap::tm_raster(
    col.scale = tm_scale_continuous(values = "viridis"),
    col.legend = tm_legend(title = "Elevation (m)", reverse = T)) + 
  tmap::tm_graticules(lines = T, labels.rot = c(0, 90), lwd = 0.2) +
  tmap::tm_scalebar(position = c("LEFT", "BOTTOM"), text.size = 0.5) + 
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("top","left"))+
  tmap::tm_basemap("Esri.WorldImagery")

# Outputs
writeRaster(dem_condt_7arc, "../assets/TIF/dem_7arc_condt.tif", overwrite=T)
writeRaster(dem_condt_5arc, "../assets/TIF/dem_5arc_condt.tif", overwrite=T)
writeRaster(dem_dir_7arc, "../assets/TIF/dem_7arc_dir.tif", overwrite=T)
writeRaster(dem_dir_5arc, "../assets/TIF/dem_5arc_dir.tif", overwrite=T)
writeRaster(dem_acc_7arc, "../assets/TIF/dem_7arc_acc.tif", overwrite=T)
writeRaster(dem_acc_5arc, "../assets/TIF/dem_5arc_acc.tif", overwrite=T)
```

```{r}
#| comment: NA
#| warning: false
#| message: false
#| error: false
#| echo: false
#| eval: false

dem = terra::rast("../assets/TIF/dem_7arc_condt.tif")
tmap::tmap_mode("plot")
tmap::tm_shape(dem) + 
  tmap::tm_raster(
    col.scale = tm_scale_continuous(values = "viridis"),
    col.legend = tm_legend(title = "Elevation (m)", reverse = T)) + 
  tmap::tm_graticules(lines = T, labels.rot = c(0, 90), lwd = 0.2) +
  tmap::tm_scalebar(position = c("LEFT", "BOTTOM"), text.size = 0.5) + 
  tmap::tm_compass(color.dark="gray60",text.color="gray60",position=c("top","left"))+
  tmap::tm_basemap("Esri.WorldImagery")
```

![](https://raw.githubusercontent.com/seamusrobertmurphy/map-templates/refs/heads/main/assets/MAP/elevation_map_2D.png){fig-align="center"}

Figure 3b Map of conditioned elevation model clipped to
extracted shoreline

## 3.4 Extract Sub-basin

```{r}
#| warning: false
#| message: false
#| comment: NA
#| eval: false
#| echo: true
dem = terra::rast("../assets/TIF/dem_7arc_condt.tif")
```

## 3.5 Delineate Streams

```{r}
#| comment: NA
#| warning: false
#| message: false
#| eval: false
#| echo: true
# Calculate Flow Accumulation Distribution
par(mfrow = c(2, 2))
thresholds <- c(1, 2, 10, 20, 50, 100)

for(thresholds in c(1, 2, 10, 20, 50, 100)) {
  count <- sum(acc_values >= thresholds, na.rm = TRUE)
   percent <- (count / length(acc_values)) * 100
   cat("Threshold", thresholds, ":", count, "cells (", round(percent, 2), "%)\n")
}

acc_values <- values(dem_acc, na.rm = TRUE)
quantile(acc_values, probs = c(0.5, 0.9, 0.95, 0.99, 0.995, 0.999), na.rm = TRUE)
upper_limit <- quantile(acc_values, 0.99, na.rm = TRUE)
acc_subset <- acc_values[acc_values <= upper_limit]
low_vals <- acc_values[acc_values <= 10 & acc_values >= 2]
med_vals <- acc_values[acc_values <= 50 & acc_values >= 2]
high_vals <- acc_values[acc_values <= 100 & acc_values >= 2]
hist(low_vals, breaks = 10, main = "Flow Accumulation: 1-10", xlab = "Accumulation")
hist(med_vals, breaks = 25, main = "Flow Accumulation: 1-50", xlab = "Accumulation")
hist(high_vals, breaks = 50, main = "Flow Accumulation: 1-100", xlab = "Accumulation")
#hist(acc_subset, breaks = 500, main="Flow Accumulation (<99%)", xlab="Flow Accumulation")
hist(log10(acc_values+1),breaks=50,main="Log10 Accumulation)", xlab="Log10 Accumulation")

# Delineate streams using flow accumulation
streams_binary = dem_acc > 100
streams = sf::st_as_sf(as.polygons(streams_binary == 1))
st_write(streams, "../assets/SHP/streams_100.shp", delete_dsn=T)
```

```{r}
#| comment: NA
#| warning: false
#| message: false
#| error: false
#| echo: false
#| eval: true

par(mfrow = c(2, 2))
dem_acc   = terra::rast("../assets/TIF/dem_7arc_acc.tif")
dem_condt = terra::rast("../assets/TIF/dem_7arc_condt.tif")

acc_values <- values(dem_acc, na.rm = TRUE)
thresholds <- c(1, 2, 10, 20, 50, 100)
for(thresholds in c(1, 2, 10, 20, 50, 100)) {
  count <- sum(acc_values >= thresholds, na.rm = TRUE)
   percent <- (count / length(acc_values)) * 100
   cat("Threshold", thresholds, ":", count, "cells (", round(percent, 2), "%)\n")
   }

quantile(acc_values, probs = c(0.5, 0.9, 0.95, 0.99, 0.995, 0.999), na.rm = TRUE)
upper_limit <- quantile(acc_values, 0.99, na.rm = TRUE)
acc_subset <- acc_values[acc_values <= upper_limit]
low_vals <- acc_values[acc_values <= 10 & acc_values >= 2]
med_vals <- acc_values[acc_values <= 50 & acc_values >= 2]
high_vals <- acc_values[acc_values <= 100 & acc_values >= 2]
hist(low_vals, breaks = 10, main = "Flow Accumulation: 1-10", xlab = "Accumulation")
hist(med_vals, breaks = 25, main = "Flow Accumulation: 1-50", xlab = "Accumulation")
hist(high_vals, breaks = 50, main = "Flow Accumulation: 1-100", xlab = "Accumulation")
#hist(acc_subset, breaks = 500, main="Flow Accumulation (<99%)", xlab="Flow Accumulation")
hist(log10(acc_values+1),breaks=50,main="Log10 Accumulation)", xlab="Log10 Accumulation")
```

```{r}
#| comment: NA
#| warning: false
#| message: false
#| eval: false
#| echo: false

#url_rivers <- "https://data.hydrosheds.org/file/HydroRIVERS/HydroRIVERS_v10_shp.zip"
#url_lakes <- "https://data.hydrosheds.org/file/hydrolakes/HydroLAKES_polys_v10_shp.zip"
#url_watersheds <- "https://data.hydrosheds.org/file/hydrobasins/customized_with_lakes/hybas_lake_af_lev01-12_v1c.zip"
#download.file(url = url, path = getwd(), destfile = file_name)

crs_master = "EPSG:3005"
island_shoreline = sf::st_read("../assets/SHP/island_shoreline.shp", quiet=T)
rivers = sf::st_read("../datasets/HYDRO/Rivers/NAm/HydroRIVERS_v10_na.shp") |>
  dplyr::select(ORD_FLOW) |>   
  sf::st_intersection(island_shoreline) |>  
  sf::st_cast() |> 
  sf::st_transform(crs_master)

basins = sf::st_read("../datasets/HYDRO/Basins/hybas_lake_na_lev06_v1c.shp") |>
  dplyr::select(HYBAS_ID) |>   
  sf::st_intersection(island_shoreline) |>  
  sf::st_cast() |> 
  sf::st_transform(crs_master)

lakes = sf::st_read("../datasets/HYDRO/Lakes/HydroLAKES_polys_v10.shp") |>
  dplyr::select(Lake_name) |>   
  sf::st_intersection(island_shoreline) |>  
  sf::st_cast() |> 
  sf::st_transform(crs_master)

island_shoreline = sf::st_read("./assets/SHP/island_shoreline.shp", quiet=T)|> 
  sf::st_transform(crs_master)

sf::st_write(lakes, "./assets/SHP/lakes.shp", delete_dsn=T)
sf::st_write(basins, "./assets/SHP/basins.shp", delete_dsn=T)
sf::st_write(rivers, "./assets/SHP/streams.shp", delete_dsn=T)
```

## 3.6 Build 3D Map

```{r}
#| comment: NA
#| message: false
#| warning: false
#| error: false
#| eval: false
#| echo: true

lakes = sf::st_read("../assets/SHP/lakes.shp") |> sf::st_cast("POLYGON")
basins= sf::st_read("../assets/SHP/basins.shp") |> sf::st_cast("MULTIPOLYGON")
rivers= sf::st_read("../assets/SHP/streams.shp")|> sf::st_cast("MULTILINESTRING")
dem   = terra::rast("../assets/TIF/dem_7arc_condt.tif") 
h <- nrow(dem)
w <- ncol(dem)

matrix = rayshader::raster_to_matrix(dem) 

matrix |>
  rayshader::height_shade() |>
  rayshader::add_overlay(
    rayshader::generate_line_overlay(
      geometry   = rivers,
      extent     = dem,
      heightmap  = matrix,
      color      = "royalblue",
      linewidth  = 3,
      ), alphalayer = 1
    ) |>
  rayshader::plot_3d(
    matrix,
    zscale       = 69,
    solid        = T,
    shadow       = T,
    shadow_darkness = 2,
    background   = "white",
    windowsize   = 800,
    zoom         = 0.8,
    phi          = 89.9,
    theta        = 0 
  )

#rayshader::render_snapshot(
#  rayvertex_lighting  = T,
#  rayvertex_lights    = 
#    rayvertex::directional_light(
#      intensity       = 1.5, 
#      color           = "#F3EEE1", 
#      direction       = c(-1.5,1,-1.5)
#      ),
#  rayvertex_shadow_map= T, 
#  software_render     = T
#  )
```

## 3.7 Render 3D Map

```{r map-render}
#| eval: false
#| echo: true
#| error: false
#| message: false
#| warning: false
#| comment: NA

rayshader::render_highquality(
  samples           = 400, 
  sample_method     = "sobol", 
  parallel          = T, 
  environment_light = "kiara_1_dawn_2k.hdr", 
  light             = T, 
  width             = w, 
  height            = h,
  preview           = T, 
  interactive       = F,
  backgroundhigh="#FFFFFF",
  backgroundlow="#FFFFFF"
  )
```

![](https://raw.githubusercontent.com/seamusrobertmurphy/map-templates/refs/heads/main/assets/MAP/stream_map_high_b.png)

```{r notes-render}
#| comment: NA
#| warning: false
#| message: false
#| eval: false
#| echo: false


# ------------------------------------------------- #

basins_line = rayshader::generate_polygon_overlay(
  geometry  = rivers, 
  heightmap = mat, 
  extent = terra::ext(dem_condt), 
  linewidth = 1
  )  
  
rivers_line = rayshader::generate_line_overlay(
  geometry  = rivers, 
  heightmap = mat, 
  extent = terra::ext(dem), 
  linewidth = 1, 
  color = "white"
  )  

mat |> rayshader::constant_shade(color = "lightgoldenrod") |> 
  rayshader::add_overlay(basins_line, alphalayer = 0.9) |>
  rayshader::add_overlay(rivers_line, alphalayer = 0.9)

rayshader::plot_3d(mat, 
  zscale    = 69, 
  windowsize= 800,
  theta     = 0,
  phi       = 89.9,
  zoom      = 0.9, 
  solid     = F, 
  lineantialias=F
  )
  
rayshader::render_highquality(
  samples       = 400, 
  sample_method = "sobol", 
  parallel      =T, 
  environment_light = "kiara_1_dawn_2k.hdr", 
  rotat_env = 135, 
  light = T, 
  width = 2000, 
  height = 2000, 
  preview = T, 
  interactive = F
  )


rayshader::render_snapshot(
  rayvertex_lighting = T,
  rayvertex_lights   = 
    rayvertex::directional_light(
      intensity = 1.5, 
      color = "#F3EEE1", 
      direction=c(-1.5,1,-1.5)
      ),
  rayvertex_shadow_map = T, software_render =T
  )

rayshader::render_highquality(
  samples       = 400, 
  sample_method = "sobol", 
  parallel      = T, 
  preview       = T,
  light         = F,
  lightdirection= c(135, 45),
  lightcolor = c("lightgoldenrod"),
  lightaltitude = 25,
  ambient_light = 0.1,
  rotate_env    = 135,
  intensity_env = 0.85,
  interactive   = F,
  parallel      = T,
  width         = w,
  height        = h,
  backgroundhigh= "#FFFFFF",
  backgroundlow = "#FFFFFF"
  )


```

### Runtime Log

```{r session-info}
#| eval: true
devtools::session_info()
```

[^index-1]: Breach-fill algorithm by Lindsay's paper (2016)
    "Efficient hybrid breaching-filling sink removal methods
    for flow path enforcement in digital elevation models:
    Efficient Hybrid Sink Removal Methods for Flow Path
    Enforcement: (Hydrological Processes 30, 846â€“857.
    doi:10.1002/hyp.10648) -\>
    `flowdem::comp_breach_lindsay2016(dem)`
